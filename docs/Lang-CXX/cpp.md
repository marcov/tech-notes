# C++

## Converting a C-string to int and check for errors

### Using stringstream
Note that `stringstream` is done to handle sequences of values.
So, when there's only a value to parse, we expect to parse it fully till EOF.
```
#include <sstream>

using namespace std;
bool convert(int* number, const char* cstr)
{
    stringstream ss(cstr);

    ss >> *number;

    //
    // fail is set if the string does not start with a number
    // eof is set only if we parse the full string till \0
    //
    if (ss.fail() || !ss.eof()) {
        cout << "CONVERSION FAILED" << endl;
        return false;
    }

    return true;
}
```

If needing to parse multiple value, then we can use `ss.peek() != ' '` to detect
error a check.

### override
Used to say that a derived class is overriding a virtual function of a base class.
`override` allows the compiler to check you are not doing mistakes e.g. not really
overriding a function, but e.g. overloading or defining a different one.

### virtual
Used  to say "may be redefined later in a derived  class". Pure virtual `= 0` means
the derived class _must_ define it (it makes the class an "abstract class").
>
> NOTE:
> - **There is no such thing as virtual constructor**. And note that constructors are
>   not inherited.
> - You can have **virtual destructors**.
> - You can have **pure virtual destructors**, but their body must _also_ be defined.
>   The purpose of them is to disallow to instantiate an object from that class.
>

### Virtual destructor
Making the base class destructor virtual guarantees that _also_ the derived class
destructor is properly called. The destructor are called from the deepest inheritance
level up to the base class.
Making a destructor virtual guarantees that all destructors are called.

## Kind of inheritances
```
class A
{
    public:
       int x;
    protected:
       int y;
    private:
       int z;
};

class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A    // 'private' is default for classes
{
    // x is private
    // y is private
    // z is not accessible from D
};
```

## Smart Pointers

### Shared Pointer
Shared pointer for a dynamically allocated uint8_t buffer.
```
std::shared_ptr<uint8_t> bufferPtr {new uint8_t[size]}, std::default_delete<uint8_t[]>()};
```

### Unique Pointer
Unique pointer for a dynamically allocated uint8_t buffer.
```
std::unique_ptr<uint8_t []> bufferPtr {new uint8_t[size]};
//
//...
//
std::unique_ptr<uint8_t[]> anotherPtr = std::move(bufferPtr);
```

## Constructor quirks

### Explicit default constructor

Consider this code:

```cpp
struct Default
{
    int a;
    unsigned long b;
    unsigned long b2;
    void* c;

    Default(void) = default;
};

struct NonDefault
{
    int a;
    unsigned long b;
    void* c;

    NonDefault() :
        a(0),
        b('\0'),
        c(nullptr)
    {
        puts("Called ctor");
    }
};

static Default sd;

int main(void)
{
    Default d;
    NonDefault n;

    Default dd{};
}
```

- The `d` constructor here is _NOT_ called, so its members here are _NOT_
initialized.

- The `n` constructor is called and its members initialized accordingly.

- We explicitly call the `dd` constructors, so its members are initialized to
the zero default value.

- The `sd` constructor is called for static objects.

So, when declaring an object with an explicit default constructor, and the
class has only built-in types, and the object is declared on the stack / heap,
then we need to explicitly call the constructor to zero-initialize members.

However, if the class has a constructor (with or without member initializer
list like `NonDefault`), then those members are always set to the values
defined in the constructor.

More in details, for the `Default` class, there is no `Default::Default` symbol
generated by the compiler, but for the `NonDefault`, there is
`NonDefault::NonDefault` symbol.

With the `Default d;` statement, the compiler doesn't do any initialization at
all.

For the `Defafault dd{};` statement, the compiler directly does a
`movq 0x0, OFFSET(%REGISTER)` for each member of the class.

For the `NonDefault n;` statment, the compiler calls `NonDefault::NonDefault`.

If the `Default` class had a class member with a constructor, then in turn the
compiler would had generated a `Default::Default` symbol, but that would again
not zero-initialize the built-in members.
